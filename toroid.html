<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Torus ↔ Flat map — mapped rect / spiral / cross square (class-driven, documented)</title>
<style>
  html,body{height:100%;margin:0;background:#0b0f14;color:#e6e6e6;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;}
  #c{width:100vw;height:100vh;display:block}
  #ui{position:fixed;left:12px;top:10px;z-index:50;background:rgba(0,0,0,0.72);padding:12px;border-radius:8px;font-size:13px;line-height:1.35;min-width:520px;max-width:46vw;overflow:auto;max-height:92vh;}
  .row{margin:6px 0}
  .lbl{display:inline-block;width:190px;opacity:.9}
  input[type=range]{width:180px}
  select,input,button{vertical-align:middle}
  .legend{margin-top:8px;opacity:.85}
  .sw{display:inline-block;width:12px;height:12px;margin-right:6px;vertical-align:-2px}
  .u{background:#ff6060}.v{background:#60a0ff}
  label.inline{display:inline-flex;align-items:center;gap:8px}
  hr{border-color:rgba(255,255,255,0.06);margin:8px 0}
  button{padding:5px 9px;border-radius:6px;border:1px solid rgba(255,255,255,0.18);background:#1a2330;color:#e6e6e6;cursor:pointer}
  button:active{transform:translateY(1px)}
</style>
</head>
<body>
<div id="ui">
  <div class="row"><span class="lbl">Mode</span>
    <select id="mode"><option value="std">Standard torus (R³)</option><option value="clifford">Clifford torus (stereo)</option></select>
  </div>

  <div class="row"><span class="lbl">Equal arclength (std)</span><input id="eqArc" type="checkbox"></div>
  <div class="row"><span class="lbl">Spiral / Shear mapping</span><input id="spiral" type="checkbox"></div>
  <div class="row"><span class="lbl">Twist (turns)</span><input id="twist" type="range" min="-4" max="4" step="0.25" value="1"><span id="twistv" style="margin-left:8px">0.75</span></div>

  <div class="row"><span class="lbl">Major R</span><input id="R" type="range" min="0.4" max="2.5" step="0.01" value="1.2"><span id="Rval" style="margin-left:8px">1.20</span></div>
  <div class="row"><span class="lbl">Minor r</span><input id="r" type="range" min="0.05" max="1.2" step="0.01" value="0.44"><span id="rval" style="margin-left:8px">0.44</span></div>

  <div class="row"><span class="lbl">U segs (base)</span><input id="su" type="range" min="8" max="256" step="1" value="96"><span id="suval" style="margin-left:8px">96</span></div>
  <div class="row"><span class="lbl">V segs</span><input id="sv" type="range" min="8" max="256" step="1" value="96"><span id="svval" style="margin-left:8px">96</span></div>

  <hr>

  <div class="row"><label class="inline"><input id="showOverlay" type="checkbox" checked> Show torus overlay</label></div>
  <div class="row"><label class="inline"><input id="showPlaneOverlay" type="checkbox" checked> Show flat map overlay</label></div>

  <div style="margin-top:8px;font-size:12px;opacity:.9">Coloring controls (applied to both surfaces):</div>
  <div class="row"><span class="lbl">Symmetry axis</span>
    <select id="symAxis"><option value="none">none</option><option value="u">u (around hole)</option><option value="v">v (tube)</option></select>
  </div>
  <div class="row"><span class="lbl">Symmetry count</span><input id="symCount" type="range" min="1" max="8" step="1" value="4"><span id="symCountV" style="margin-left:8px">4</span></div>
  <div class="row"><span class="lbl">Symmetry strength</span><input id="symStrength" type="range" min="0" max="1" step="0.01" value="0.6"><span id="symStrengthV" style="margin-left:8px">0.60</span></div>

  <hr>

  <div style="font-size:13px;margin-bottom:6px">Flat rectangle (maps → torus perimeter)</div>
  <div class="row"><span class="lbl">Rect U center</span><input id="rectU" type="range" min="0" max="1" step="0.001" value="0.5"><span id="rectUv" style="margin-left:8px">0.50</span></div>
  <div class="row"><span class="lbl">Rect V center</span><input id="rectV" type="range" min="0" max="1" step="0.001" value="0.5"><span id="rectVv" style="margin-left:8px">0.50</span></div>
  <div class="row"><span class="lbl">Rect U size</span><input id="rectUsz" type="range" min="0.01" max="1" step="0.001" value="0.2"><span id="rectUszv" style="margin-left:8px">0.20</span></div>
  <div class="row"><span class="lbl">Rect V size</span><input id="rectVsz" type="range" min="0.01" max="1" step="0.001" value="0.2"><span id="rectVszv" style="margin-left:8px">0.20</span></div>
  <div class="row">
    <label class="inline"><input id="drawMappedRect" type="checkbox" checked> Draw mapped rectangle perimeter</label>
  </div>

  <hr>

  <div style="font-size:13px;margin-bottom:6px">Section helpers (around u = θ)</div>
  <div class="row"><span class="lbl">θ (U around hole)</span><input id="theta" type="range" min="0" max="1" step="0.001" value="0.18"><span id="thetav" style="margin-left:8px">0.18</span></div>
  <div class="row"><span class="lbl">Size (multiplier of tube radius)</span><input id="size" type="range" min="0.01" max="2.0" step="0.01" value="1.00"><span id="sizev" style="margin-left:8px">1.00</span></div>

  <div class="row">
    <label class="inline"><input id="showSpiralArc" type="checkbox" checked> Show spiral arc (follows blue)</label>
    <label class="inline"><input id="arcCloseSingle" type="checkbox"> Close arc after 1 lap</label>
  </div>
  <div class="row">
    <label class="inline"><input id="showCrossSquare" type="checkbox" checked> Show cross-section square</label>
  </div>

  <hr>
  <div class="legend"><span class="sw u"></span>iso-v (red, vary u) &nbsp;&nbsp;<span class="sw v"></span>iso-u (blue, vary v)</div>
  <div style="margin-top:8px;opacity:.85">Click either surface to place a marker and see the equivalent point on the other.</div>
</div>

<canvas id="c"></canvas>

<script type="module">
import * as THREE from 'https://esm.sh/three@0.160.0';
import { OrbitControls } from 'https://esm.sh/three@0.160.0/examples/jsm/controls/OrbitControls.js';

/* =========================================================================
   Three.js scene setup
   - basic renderer, camera, controls, lights
   - two groups: torusGroup and planeGroup to position objects side-by-side
   ========================================================================= */

const canvas = document.getElementById('c');
const renderer = new THREE.WebGLRenderer({ canvas, antialias:true });
renderer.setClearColor(0x0b0f14, 1);
renderer.setPixelRatio(Math.min(window.devicePixelRatio||1, 2));

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(45, 1, 0.01, 100);
camera.position.set(0,1.4,6);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

scene.add(new THREE.AmbientLight(0xffffff, 0.6));
const dir = new THREE.DirectionalLight(0xffffff, 0.8); dir.position.set(1.5,2.0,1.0); scene.add(dir);

const torusGroup = new THREE.Group();
const planeGroup = new THREE.Group();
scene.add(torusGroup, planeGroup);

/* =========================================================================
   Materials and UI element references
   ========================================================================= */

const matU = new THREE.LineBasicMaterial({ color:0xff6060, transparent:true, opacity:0.95 });
const matV = new THREE.LineBasicMaterial({ color:0x60a0ff, transparent:true, opacity:0.95 });
const planeFillMat = new THREE.MeshBasicMaterial({ color:0x2a8f66, side:THREE.DoubleSide, transparent:true, opacity:0.25 });

const mapRectMat = new THREE.LineBasicMaterial({ color:0x00ddff });   // cyan for plane rect
const mappedTorMat = new THREE.LineBasicMaterial({ color:0x00ff88 });  // green for mapped rect on torus
const arcMat       = new THREE.LineBasicMaterial({ color:0x33ff66 });  // green arc on torus
const planeArcMat  = new THREE.LineBasicMaterial({ color:0x33ff66 });  // green arc on plane
const squareMat    = new THREE.LineBasicMaterial({ color:0x33ff66 });  // green square on torus

/* ---------- UI element shortcuts ---------- */
const modeSel = document.getElementById('mode');
const eqArc   = document.getElementById('eqArc');
const spiral  = document.getElementById('spiral');
const twistEl = document.getElementById('twist');
const twistV  = document.getElementById('twistv');

const Rslider = document.getElementById('R');
const rslider = document.getElementById('r');
const suslider= document.getElementById('su');
const svslider= document.getElementById('sv');
const Rval = document.getElementById('Rval'), rval = document.getElementById('rval');
const suval = document.getElementById('suval'), svval = document.getElementById('svval');

const showOverlay = document.getElementById('showOverlay');
const showPlaneOverlay = document.getElementById('showPlaneOverlay');
const symAxis = document.getElementById('symAxis');
const symCount = document.getElementById('symCount');
const symCountV = document.getElementById('symCountV');
const symStrength = document.getElementById('symStrength');
const symStrengthV = document.getElementById('symStrengthV');

const rectU = document.getElementById('rectU'), rectUv = document.getElementById('rectUv');
const rectV = document.getElementById('rectV'), rectVv = document.getElementById('rectVv');
const rectUsz = document.getElementById('rectUsz'), rectUszv = document.getElementById('rectUszv');
const rectVsz = document.getElementById('rectVsz'), rectVszv = document.getElementById('rectVszv');
const drawMappedRect = document.getElementById('drawMappedRect');

const thetaEl = document.getElementById('theta'), thetav = document.getElementById('thetav');
const sizeEl = document.getElementById('size'), sizev = document.getElementById('sizev');

const showSpiralArc   = document.getElementById('showSpiralArc');
const arcCloseSingle  = document.getElementById('arcCloseSingle');
const showCrossSquare = document.getElementById('showCrossSquare');

/* =========================================================================
   Constants and parametric surface functions
   - stdPos: standard torus parameterization (u,v angles in radians)
   - cliffordPos: Clifford torus stereographic mapping for alternate appearance
   - NOTE: display ordering swaps y and z to match original layout
   ========================================================================= */

const TWO_PI = Math.PI*2;

/**
 * Standard torus parameterization
 * u - angle around main hole (radians)
 * v - angle around tube (radians)
 * Rv - major radius
 * rv - minor radius
 * returns THREE.Vector3 in display coordinate ordering (x, z, y) to match original visuals
 */
function stdPos(u,v,Rv,rv){
  const cu=Math.cos(u), su=Math.sin(u), cv=Math.cos(v), sv=Math.sin(v);
  const x=(Rv+rv*cv)*cu;
  const y=(Rv+rv*cv)*su;
  const z=rv*sv;
  // return new Vector3(x, z, y) so the scene's up/forward remain consistent with original
  return new THREE.Vector3(x, z, y);
}

/**
 * Clifford torus stereographic mapping
 * used for the alternative 'clifford' mode
 * The scale parameter adjusts stereographic projection scale
 */
function cliffordPos(u,v,scale=1.8){
  const s = Math.SQRT1_2;
  const x1 = s * Math.cos(u);
  const y1 = s * Math.sin(u);
  const z1 = s * Math.cos(v);
  const w1 = s * Math.sin(v);
  const d = 1 - w1;
  return new THREE.Vector3((x1 / d) * scale, (z1 / d) * scale, (y1 / d) * scale);
}

/* =========================================================================
   small linear algebra helper - 3x3 solver
   - used by cross-square Kasa circle fit
   ========================================================================= */

/**
 * Solve a 3x3 linear system A x = b using Gaussian elimination
 * A - 3x3 array-of-arrays
 * b - length-3 array
 * returns array [x0,x1,x2] or null on singular matrix
 */
function solve3x3(A, b){
  const M = [
    [A[0][0],A[0][1],A[0][2], b[0]],
    [A[1][0],A[1][1],A[1][2], b[1]],
    [A[2][0],A[2][1],A[2][2], b[2]]
  ];
  for(let i=0;i<3;i++){
    let piv=i;
    for(let j=i+1;j<3;j++) if(Math.abs(M[j][i])>Math.abs(M[piv][i])) piv=j;
    if(Math.abs(M[piv][i])<1e-12) return null;
    if(piv!==i){ const tmp=M[i]; M[i]=M[piv]; M[piv]=tmp; }
    const d = M[i][i];
    for(let k=i;k<4;k++) M[i][k]/=d;
    for(let j=0;j<3;j++) if(j!==i){
      const f=M[j][i];
      if(Math.abs(f) < 1e-18) continue;
      for(let k=i;k<4;k++) M[j][k] -= f*M[i][k];
    }
  }
  return [M[0][3], M[1][3], M[2][3]];
}

/* =========================================================================
   TorusMapper class
   - encapsulates mapping logic from fractional UV (0..1) to 3D
   - provides helpers to sample the rectangle perimeter, spiral arc, cross-square
   - outputs are plain JS arrays suitable for building line geometry
   ========================================================================= */

/**
 * TorusMapper
 * @class
 * @param {Object} params - initial parameters
 * @param {'std'|'clifford'} params.mode - mapping mode
 * @param {number} params.R - major radius (for std mode)
 * @param {number} params.r - minor radius (for std mode)
 * @param {number} params.shear - shear factor: u <- u + shear * v (for spiral mapping)
 */
class TorusMapper {
  constructor(params = {}) {
    // default parameters
    this.params = Object.assign({
      mode: 'std',
      R: 1.2,
      r: 0.44,
      shear: 0.0
    }, params);
    this.TWO_PI = Math.PI * 2;
  }

  /**
   * Update parameters in place
   * @param {Object} newParams - partial params to merge
   * @returns {TorusMapper} this
   */
  updateParams(newParams = {}){ Object.assign(this.params, newParams); return this; }

  /**
   * Set a single parameter
   * @param {string} k - key
   * @param {*} v - value
   * @returns {TorusMapper} this
   */
  setParam(k,v){ this.params[k]=v; return this; }

  /**
   * Return a shallow copy of current params
   * @returns {Object}
   */
  getParams(){ return Object.assign({}, this.params); }

  /**
   * Internal: wrap fractional value into [0,1)
   * @param {number} x
   * @returns {number}
   */
  _wrap01(x){ x%=1; return x<0?x+1:x; }

  /**
   * Internal: get position function based on mode
   * @returns {Function} function(uRadians,vRadians) -> THREE.Vector3
   */
  _getPosFunc(){
    if(this.params.mode === 'clifford') return (u,v)=>cliffordPos(u,v,1.8);
    return (u,v)=>stdPos(u,v,this.params.R,this.params.r);
  }

  /**
   * Map fractional UV in [0,1) to 3D position in world/local torus space
   * - applies shear: u' = u + shear * v
   * @param {number} U - fractional U in [0,1)
   * @param {number} V - fractional V in [0,1)
   * @returns {THREE.Vector3}
   */
  posFromUV(U,V){
    const shear = this.params.shear || 0.0;
    const u = this._wrap01(U) * this.TWO_PI;
    const v = this._wrap01(V) * this.TWO_PI;
    const getPos = this._getPosFunc();
    return getPos(u + shear * v, v);
  }

  /**
   * Compute local frame at fractional UV
   * - numeric finite differences used to estimate tangent directions
   * @param {number} U fractional u
   * @param {number} V fractional v
   * @param {number} [eps=1e-4] small step for finite difference
   * @returns {{p:THREE.Vector3, tu:THREE.Vector3, tv:THREE.Vector3, n:THREE.Vector3}}
   */
  frameAt(U,V,eps=1e-4){
    const P = this.posFromUV(U,V);
    const Pu = this.posFromUV(U+eps,V);
    const Pv = this.posFromUV(U,V+eps);
    const tu = Pu.clone().sub(P).normalize();
    const tv = Pv.clone().sub(P).normalize();
    const n = tu.clone().cross(tv).normalize();
    return { p:P, tu, tv, n };
  }

  /**
   * Build the rectangle perimeter mapped to plane and torus
   * - returns uv list, planePts (3D coords on plane), torusPts (3D coords on torus)
   * - also splits the continuous perimeter into loops where wrapping occurs
   *
   * @param {number} Uc center U (fractional)
   * @param {number} Vc center V (fractional)
   * @param {number} Usz size in U (fractional, 0..1)
   * @param {number} Vsz size in V (fractional, 0..1)
   * @param {number} [edge=128] number of samples per edge
   * @returns {{
   *   uv:Array, planePts:Array, torusPts:Array,
   *   planeLoops:Array<Array>, torusLoops:Array<Array>
   * }}
   */
  rectPerimeterData(Uc,Vc,Usz,Vsz, edge=128){
    const Umin = Uc - Usz/2, Umax = Uc + Usz/2, Vmin = Vc - Vsz/2, Vmax = Vc + Vsz/2;

    // Build a continuous list of UVs tracing the rectangle perimeter
    const uv_cont = [];
    for(let i=0;i<=edge;i++){ const t=i/edge; uv_cont.push([Umin+t*(Umax-Umin), Vmax]); }
    for(let i=1;i<=edge;i++){ const t=i/edge; uv_cont.push([Umax, Vmax+t*(Vmin-Vmax)]); }
    for(let i=1;i<=edge;i++){ const t=i/edge; uv_cont.push([Umax+t*(Umin-Umax), Vmin]); }
    for(let i=1;i<edge;i++){ const t=i/edge; uv_cont.push([Umin, Vmin+t*(Vmax-Vmin)]); }

    // Map to plane coordinates for visualization: plane uses [-PI, PI] range along each axis
    const planePts = uv_cont.map(([U,V])=>[(this._wrap01(U)-0.5)*this.TWO_PI, 0, (this._wrap01(V)-0.5)*this.TWO_PI]);

    // Map to torus coordinates using posFromUV
    const torusPts  = uv_cont.map(([U,V])=>{ const P = this.posFromUV(U,V); return [P.x,P.y,P.z]; });

    // Now split the continuous sequence into loops where the plane jumps across seams
    // If a consecutive segment jumps more than PI in either plane axis, we break the loop
    const planeLoops = [], torusLoops = [];
    let curPlane = [], curTorus = [];

    function pushCurrent(){
      if(curPlane.length>0){
        planeLoops.push(curPlane.slice());
        torusLoops.push(curTorus.slice());
      }
      curPlane = []; curTorus = [];
    }

    if(planePts.length>0){ curPlane.push(planePts[0]); curTorus.push(torusPts[0]); }

    for(let i=1;i<planePts.length;i++){
      const a = planePts[i-1], b = planePts[i];
      // difference along plane axes
      const dx = Math.abs(b[0]-a[0]), dz = Math.abs(b[2]-a[2]);
      // If jump is large - typically due to wrap, break the current loop
      if(dx > Math.PI || dz > Math.PI){ pushCurrent(); }
      curPlane.push(b); curTorus.push(torusPts[i]);
    }
    if(curPlane.length>0) pushCurrent();

    return { uv: uv_cont, planePts, torusPts, planeLoops, torusLoops };
  }

  /**
   * Produce a spiral arc along V vs U0
   * - thetaRad given in radians specifying base U location
   * - optional 'close1' mode will close after 1 lap when shear is present
   *
   * @param {number} thetaRad - starting theta in radians
   * @param {number} offset - offset outwards along normalized position (optional)
   * @param {Object} opts - options: {mode:'blue'|'close1', samples:number}
   * @returns {{mode:string, U0:number, k:number, torusPts:Array, planePts:Array, uv:Array}}
   */
  spiralArcData(thetaRad, offset=0, opts={mode:'blue', samples:320}){
    const mode = opts.mode || 'blue';
    const S = opts.samples || 320;
    const U0 = this._wrap01(thetaRad / this.TWO_PI);
    const torusPts = [], planePts = [], uv = [];
    const shear = this.params.shear || 0.0;

    // k is non-zero when we want the U to slide with the arc so that it closes after one lap
    const k = (mode === 'close1') ? (Math.round(shear) - shear) : 0.0;

    for(let i=0;i<=S;i++){
      const t = i / S;
      const U = this._wrap01(U0 + k * t); // apply closure shift if requested
      const V = this._wrap01(t);
      const P = this.posFromUV(U, V);
      const out = P.clone().normalize().multiplyScalar(offset);
      torusPts.push([P.x + out.x, P.y + out.y, P.z + out.z]);
      planePts.push([(this._wrap01(U)-0.5)*this.TWO_PI, 0, (this._wrap01(V)-0.5)*this.TWO_PI]);
      uv.push([U, V]);
    }

    // If requested to close after one lap, duplicate the first point at the end
    if(mode === 'close1'){
      torusPts[torusPts.length-1] = [...torusPts[0]];
      planePts[planePts.length-1] = [...planePts[0]];
      uv[uv.length-1] = [...uv[0]];
    }

    return { mode, U0, k, torusPts, planePts, uv };
  }

  /**
   * Cross-section square around the tube at U = thetaRad
   * - fits a circle in the local tube plane and builds an axis-aligned square around that circle
   * - returns exactly 4 corner points (no duplicate closing point)
   *
   * @param {number} thetaRad - U position in radians
   * @param {number} sizeMultiplier - multiplier of fitted radius used for half-size
   * @returns {{
   *   U:number,
   *   center:Array<number>,
   *   axes:{x:Array,y:Array,n:Array},
   *   torusPts:Array<Array<number>>,
   *   planePts:Array<Array<number>>
   * }}
   */
  crossSquareData(thetaRad, sizeMultiplier=1.0){
    const U = this._wrap01(thetaRad / this.TWO_PI);
    const S = 256, eps = 1e-3;

    // Sample tube ring points P(U, v) for v in [0,1)
    const Ps = new Array(S);
    let C0 = new THREE.Vector3(0,0,0);
    for(let i=0;i<S;i++){ const V=i/S; const P=this.posFromUV(U,V); Ps[i]=P; C0.add(P); }
    C0.multiplyScalar(1/S); // centroid of sampled ring - fallback center

    // Estimate plane normal by averaging cross products of successive centered vectors
    let n = new THREE.Vector3(0,0,0);
    for(let i=0;i<S;i++){
      const a = Ps[i].clone().sub(C0);
      const b = Ps[(i+1)%S].clone().sub(C0);
      n.add(a.clone().cross(b));
    }
    // If degeneracy occurs, fallback to derivative-based normal
    if(n.lengthSq() < 1e-12){
      const P0 = this.posFromUV(U,0.0);
      const Pv = this.posFromUV(U, eps);
      n = Pv.clone().sub(P0).cross(P0.clone().sub(this.posFromUV(U+eps,0))).normalize();
      if(n.lengthSq() < 1e-12) n = new THREE.Vector3(0,1,0);
    }
    n.normalize();

    // Choose local axes ex and ey spanning the plane
    // ex is computed by averaging radial-type vectors projected to the plane
    let ex = new THREE.Vector3(0,0,0);
    for(let i=0;i<S;i++){
      const v = Ps[i].clone().sub(C0);
      const proj = n.clone().multiplyScalar(v.dot(n));
      ex.add(v.clone().sub(proj));
    }
    if(ex.lengthSq() < 1e-12){
      if(Math.abs(n.x) < 0.9) ex = new THREE.Vector3(1,0,0).cross(n).normalize();
      else ex = new THREE.Vector3(0,1,0).cross(n).normalize();
    } else ex.normalize();

    const ey = n.clone().cross(ex).normalize();

    // Project sampled points into plane coordinates to fit a circle using Kasa method
    const xs = new Float64Array(S), ys = new Float64Array(S);
    for(let i=0;i<S;i++){
      const v = Ps[i].clone().sub(C0);
      xs[i] = v.dot(ex);
      ys[i] = v.dot(ey);
    }

    // Build normal equations to solve xi^2 + yi^2 + A xi + B yi + C = 0
    let M = [[0,0,0],[0,0,0],[0,0,0]];
    let rhs = [0,0,0];
    for(let i=0;i<S;i++){
      const xi = xs[i], yi = ys[i];
      const q = -(xi*xi + yi*yi);
      M[0][0] += xi*xi; M[0][1] += xi*yi; M[0][2] += xi;
      M[1][0] += xi*yi; M[1][1] += yi*yi; M[1][2] += yi;
      M[2][0] += xi;    M[2][1] += yi;    M[2][2] += 1;
      rhs[0] += xi*q; rhs[1] += yi*q; rhs[2] += q;
    }

    let sol = solve3x3(M, rhs);
    let center2 = { x:0, y:0 }, radius = 0;
    if(sol){
      const A = sol[0], B = sol[1], Cc = sol[2];
      center2.x = -A/2; center2.y = -B/2;
      const rad2 = center2.x*center2.x + center2.y*center2.y - Cc;
      radius = (rad2 > 0) ? Math.sqrt(rad2) : Math.sqrt(Math.max(0, (xs.reduce((s,v)=>s+v*v,0)+ys.reduce((s,v)=>s+v*v,0))/S));
    } else {
      // fallback to centroid radius
      let meanR = 0;
      for(let i=0;i<S;i++) meanR += Math.hypot(xs[i], ys[i]);
      meanR /= S;
      center2.x = 0; center2.y = 0;
      radius = meanR;
    }

    // Map fit center back to 3D
    const C = C0.clone().add(ex.clone().multiplyScalar(center2.x)).add(ey.clone().multiplyScalar(center2.y));

    // Build orthonormal square axes
    let xAxis = new THREE.Vector3(0,0,0);
    for(let i=0;i<S;i++){ const v = Ps[i].clone().sub(C); xAxis.add(v); }
    if(xAxis.lengthSq() < 1e-12) xAxis = ex.clone(); else xAxis.normalize();

    // Project xAxis to plane to ensure orthogonality to normal n
    const proj = n.clone().multiplyScalar(xAxis.dot(n));
    xAxis.sub(proj);
    if(xAxis.lengthSq() < 1e-12){
      if(Math.abs(n.x) < 0.9) xAxis = new THREE.Vector3(1,0,0).cross(n).normalize();
      else xAxis = new THREE.Vector3(0,1,0).cross(n).normalize();
    } else xAxis.normalize();

    const yAxis = n.clone().cross(xAxis).normalize();

    // Half-size scaled by fitted radius
    const h = Math.max(1e-9, sizeMultiplier) * radius;

    // Compute four corners (no duplicate closing point)
    const A3 = C.clone().add(xAxis.clone().multiplyScalar( h)).add(yAxis.clone().multiplyScalar( h));
    const B3 = C.clone().add(xAxis.clone().multiplyScalar( h)).add(yAxis.clone().multiplyScalar(-h));
    const D3 = C.clone().add(xAxis.clone().multiplyScalar(-h)).add(yAxis.clone().multiplyScalar( h));
    const E3 = C.clone().add(xAxis.clone().multiplyScalar(-h)).add(yAxis.clone().multiplyScalar(-h));

    const torusPts = [A3, B3, E3, D3].map(v=>[v.x,v.y,v.z]); // exactly 4 corners

    // planePts for cross visual: sample vertical line in plane for reference
    const planePts = [];
    for(let i=0;i<=S;i++){ const V=i/S; planePts.push([(U-0.5)*this.TWO_PI,0,(V-0.5)*this.TWO_PI]); }
    return { U, center:[C.x,C.y,C.z], axes:{x:[xAxis.x,xAxis.y,xAxis.z], y:[yAxis.x,yAxis.y,yAxis.z], n:[n.x,n.y,n.z]}, torusPts, planePts };
  }

  /**
   * uvFromXYZ_std
   * - inverse map for standard torus: given 3D position in torus local space,
   *   compute fractional (u,v) coordinates on the parametric domain.
   * - returns THREE.Vector2(Ufraction, Vfraction)
   */
  uvFromXYZ_std(pos){
    if(this.params.mode !== 'std') return null;
    const x = pos.x, y = pos.z, z = pos.y; // note swapped ordering used across code
    const u = Math.atan2(y, x);
    const Rxy = Math.hypot(x, y);
    const cv = (Rxy - this.params.R) / this.params.r;
    const v = Math.atan2(z / this.params.r, cv);
    return new THREE.Vector2(this._wrap01(u / this.TWO_PI), this._wrap01(v / this.TWO_PI));
  }
}

/* =========================================================================
   Geometry builders reused from original example
   - buildVariableRingMesh creates mesh used for picking
   - buildWireUniform draws iso-lines
   - buildPlane draws the flat uv plane
   ========================================================================= */

function buildVariableRingMesh(getPos, segU, segV, options){
  options ||= {};
  const useEq=!!options.equalArc, shear=Number(options.shear)||0.0, forceUniformU=!!options.forceUniformU;
  const Nu=new Array(segV);
  for(let j=0;j<segV;++j){
    if(forceUniformU){ Nu[j]=segU; continue; }
    const v=j/segV*TWO_PI;
    if(useEq && typeof options.R==='number'){
      const coef=(options.R + options.r*Math.cos(v));
      let n=Math.round(segU * (coef/Math.max(1e-6, options.R)));
      Nu[j]=Math.max(8, Math.min(n, segU*3));
    } else Nu[j]=segU;
  }
  const ringStart=new Array(segV); let total=0; for(let j=0;j<segV;++j){ ringStart[j]=total; total+=Nu[j]; }
  const pos=new Float32Array(total*3), uv=new Float32Array(total*2); let vi=0;
  for(let j=0;j<segV;++j){
    const Nj=Nu[j], v=j/segV*TWO_PI;
    for(let i=0;i<Nj;++i){
      const u=i/Nj*TWO_PI; const P=getPos(u+shear*v, v);
      pos[vi*3]=P.x; pos[vi*3+1]=P.y; pos[vi*3+2]=P.z;
      uv[vi*2]=u/TWO_PI; uv[vi*2+1]=v/TWO_PI; vi++;
    }
  }
  const idx=[];
  for(let j=0;j<segV;++j){
    const j2=(j+1)%segV, Na=Nu[j], Nb=Nu[j2], a0=ringStart[j], b0=ringStart[j2]; let ia=0, ib=0;
    while(ia<Na || ib<Nb){
      const an=(ia+1)/Na, bn=(ib+1)/Nb;
      if(ia<Na && (ib>=Nb || an<=bn)){ const ac=a0+(ia%Na), anp=a0+((ia+1)%Na), bc=b0+(ib%Nb); idx.push(anp,bc,ac); ia++; }
      else{ const ac=a0+(ia%Na), bc=b0+(ib%Nb), bnp=b0+((ib+1)%Nb); idx.push(bnp,bc,ac); ib++; }
    }
  }
  const g=new THREE.BufferGeometry();
  g.setAttribute('position', new THREE.BufferAttribute(pos,3));
  g.setAttribute('uv', new THREE.BufferAttribute(uv,2));
  g.setIndex(idx); g.computeVertexNormals();
  const pickMat=new THREE.MeshBasicMaterial({color:0xffffff,transparent:true,opacity:0.0,depthWrite:false,depthTest:true,side:THREE.DoubleSide});
  const mesh=new THREE.Mesh(g,pickMat); mesh.frustumCulled=false; return { mesh, Nu };
}

function buildWireUniform(getPos, segU, segV, shear=0.0){
  const TWO_PI=Math.PI*2;
  const geoU=new THREE.BufferGeometry(), geoV=new THREE.BufferGeometry();
  { const pos=new Float32Array(segV*segU*2*3); let k=0;
    for(let j=0;j<segV;++j){ const v=j/segV*TWO_PI; for(let i=0;i<segU;++i){
      const u0=i/segU*TWO_PI, u1=(i+1)/segU*TWO_PI;
      const a=getPos(u0+shear*v, v), b=getPos(u1+shear*v, v);
      pos[k++]=a.x; pos[k++]=a.y; pos[k++]=a.z; pos[k++]=b.x; pos[k++]=b.y; pos[k++]=b.z; }}
    geoU.setAttribute('position', new THREE.BufferAttribute(pos,3));
  }
  { const pos=new Float32Array(segU*segV*2*3); let k=0;
    for(let i=0;i<segU;++i){ const u=i/segU*TWO_PI; for(let j=0;j<segV;++j){
      const v0=j/segV*TWO_PI, v1=(j+1)/segV*TWO_PI;
      const a=getPos(u+shear*v0, v0), b=getPos(u+shear*v1, v1);
      pos[k++]=a.x; pos[k++]=a.y; pos[k++]=a.z; pos[k++]=b.x; pos[k++]=b.y; pos[k++]=b.z; }}
    geoV.setAttribute('position', new THREE.BufferAttribute(pos,3));
  }
  return [ new THREE.LineSegments(geoU, matU), new THREE.LineSegments(geoV, matV) ];
}

function buildPlane(segU, segV, w=TWO_PI, h=TWO_PI){
  const nx=segU+1, ny=segV+1;
  const pos=new Float32Array(nx*ny*3), uv=new Float32Array(nx*ny*2), idx=new Uint32Array(segU*segV*6);
  let p=0,t=0;
  for(let j=0;j<ny;++j){ const V=Math.min(j,segV)/segV, z=(V-0.5)*h;
    for(let i=0;i<nx;++i){ const U=Math.min(i,segU)/segU, x=(U-0.5)*w; pos[p++]=x; pos[p++]=0; pos[p++]=z; uv[t++]=U; uv[t++]=V; } }
  let k=0,row=nx;
  for(let j=0;j<segV;++j) for(let i=0;i<segU;++i){ const a=j*row+i,b=a+1,c=a+row,d=c+1; idx[k++]=a; idx[k++]=c; idx[k++]=b; idx[k++]=b; idx[k++]=c; idx[k++]=d; }
  const g=new THREE.BufferGeometry(); g.setAttribute('position', new THREE.BufferAttribute(pos,3)); g.setAttribute('uv', new THREE.BufferAttribute(uv,2)); g.setIndex(new THREE.BufferAttribute(idx,1));
  const mesh=new THREE.Mesh(g, planeFillMat.clone());
  const lines=buildWireUniform((u,v)=>new THREE.Vector3((u/TWO_PI-0.5)*w,0,(v/TWO_PI-0.5)*h), segU, segV);
  return { mesh, lines, posFromUV:(U,V)=>new THREE.Vector3((U-0.5)*w,0,(V-0.5)*h) };
}

/* =========================================================================
   Utility helpers for color, wrapping and converting arrays to lines
   ========================================================================= */

function hsvToRgb(h,s,v){ const i=Math.floor(h*6), f=h*6-i, p=v*(1-s), q=v*(1-f*s), t=v*(1-(1-f)*s); let r=0,g=0,b=0; switch(i%6){case 0:r=v;g=t;b=p;break;case 1:r=q;g=v;b=p;break;case 2:r=p;g=v;b=t;break;case 3:r=p;g=q;b=v;break;case 4:r=t;g=p;b=v;break;case 5:r=v;g=p;b=q;break;} return {r,g,b};}
function symmetricMod(u,v,axis,count,strength){ if(axis==='none'||count<=1||strength<=0) return 1.0; const t=(axis==='u')?u:v; const a=t*TWO_PI*count; const base=Math.abs(Math.cos(a*0.5)); return (1-strength)+base*strength; }

/**
 * Convert an array of [x,y,z] points into a THREE.Line
 * @param {Array<Array<number>>} pts
 * @param {THREE.Material} mat
 * @returns {THREE.Line}
 */
function toLine(pts, mat){
  const arr=new Float32Array(pts.length*3);
  for(let i=0;i<pts.length;i++){ arr[i*3]=pts[i][0]; arr[i*3+1]=pts[i][1]; arr[i*3+2]=pts[i][2]; }
  const g=new THREE.BufferGeometry(); g.setAttribute('position', new THREE.BufferAttribute(arr,3));
  const L=new THREE.Line(g, mat); L.frustumCulled=false; return L;
}

/* =========================================================================
   Scene items used for picking and visualization
   ========================================================================= */

const torusMarker = new THREE.Mesh(new THREE.SphereGeometry(0.035,16,12), new THREE.MeshBasicMaterial({ color:0xffff66 }));
const planeMarker = new THREE.Mesh(new THREE.SphereGeometry(0.045,16,12), new THREE.MeshBasicMaterial({ color:0xffff66 }));
torusMarker.visible=false; planeMarker.visible=false; torusGroup.add(torusMarker); planeGroup.add(planeMarker);

let currentPick=null, currentWires=[], planeObj=null;
let torusOverlay=null, planeOverlay=null;
let planeRectLines=null, mappedTorLines=null;
let arcLine=null, planeArcLine=null;
let squareLine=null, planeSquareLine=null;

/**
 * Dispose helper that safely disposes geometry/material and removes object from parent
 * Accepts single object or an array of objects
 */
function dispose(o){
  if(!o) return;
  if(Array.isArray(o)){ o.forEach(x=>dispose(x)); return; }
  if(o.geometry) o.geometry.dispose();
  if(o.material){ Array.isArray(o.material)?o.material.forEach(m=>m.dispose()):o.material.dispose(); }
  if(o.parent) o.parent.remove(o);
}

/**
 * Clear scene overlays and helper objects
 */
function clearAll(){
  currentWires.forEach(dispose); currentWires=[];
  [currentPick,torusOverlay,planeOverlay,planeRectLines,mappedTorLines,arcLine,planeArcLine,squareLine,planeSquareLine].forEach(dispose);
  currentPick=torusOverlay=planeOverlay=planeRectLines=mappedTorLines=arcLine=planeArcLine=squareLine=planeSquareLine=null;
  if(planeObj){ planeObj.lines.forEach(dispose); dispose(planeObj.mesh); planeObj=null; }
  torusMarker.visible=false; planeMarker.visible=false;
}

/* =========================================================================
   Main rebuild function - constructs the torus, plane and the green helpers
   - Now uses TorusMapper exclusively for mapped rectangle, spiral, and cross square
   - Logs mapper outputs to the console for inspection
   ========================================================================= */

function rebuild(){
  clearAll();

  const modeStd=(modeSel.value==='std');
  const shear = spiral.checked ? (+twistEl.value||0) : 0;

  // Instantiate mapper with current params
  const tmapper = new TorusMapper({ mode:(modeStd?'std':'clifford'), R:+Rslider.value, r:+rslider.value, shear });

  // getPos function used to build meshes and wireframes - expects radians
  const getPos = modeStd ? ((u,v)=>stdPos(u,v,+Rslider.value,+rslider.value)) : ((u,v)=>cliffordPos(u,v,1.8));

  // build pickable mesh (invisible material) that matches displayed geometry
  const built = buildVariableRingMesh(getPos, +suslider.value, +svslider.value,
    { equalArc:modeStd&&eqArc.checked, shear, forceUniformU:!!spiral, R:+Rslider.value, r:+rslider.value });
  currentPick=built.mesh; torusGroup.add(currentPick);

  // iso-lines for u and v directions
  const [uLines,vLines]=buildWireUniform(getPos, +suslider.value, +svslider.value, shear);
  currentWires.push(uLines,vLines); torusGroup.add(uLines,vLines);

  // plane mesh and its lines
  planeObj=buildPlane(+suslider.value, +svslider.value);
  planeGroup.add(planeObj.mesh, ...planeObj.lines);

  // layout - position torus and plane groups side-by-side
  currentPick.geometry.computeBoundingSphere();
  const torusR=currentPick.geometry.boundingSphere?.radius ?? (+Rslider.value + +rslider.value + 0.5);
  const planeHalf=Math.SQRT2*Math.PI, gap=0.28, span=torusR+planeHalf+gap;
  torusGroup.position.set(-span*0.6,0,0);
  planeGroup.position.set(+span*0.6,0,0);

  // overlay coloring for torus and plane meshes
  const axis=symAxis.value, cnt=Math.max(1,parseInt(symCount.value,10)), str=parseFloat(symStrength.value);
  if(showOverlay.checked){
    const g=currentPick.geometry.clone(), uv=g.getAttribute('uv'), n=g.getAttribute('position').count, col=new Float32Array(n*3);
    for(let i=0;i<n;i++){
      const u=uv.getX(i), v=uv.getY(i), a=v*TWO_PI, hue=((v%1)+1)%1, rn=(1+Math.cos(a))*0.5, fn=(1+Math.sin(a))*0.5;
      let s=0.25+0.75*rn, val=0.35+0.65*fn, m=symmetricMod(u,v,axis,cnt,str);
      s*=0.6+0.4*m; val*=0.6+0.4*m;
      const c=hsvToRgb(hue,s,val);
      col[i*3]=c.r; col[i*3+1]=c.g; col[i*3+2]=c.b;
    }
    g.setAttribute('color', new THREE.BufferAttribute(col,3));
    torusOverlay=new THREE.Mesh(g,new THREE.MeshBasicMaterial({vertexColors:true,side:THREE.DoubleSide,transparent:true,opacity:0.98}));
    torusOverlay.frustumCulled=false; torusGroup.add(torusOverlay);
  }

  if(showPlaneOverlay.checked){
    const g=planeObj.mesh.geometry.clone(), uv=g.getAttribute('uv'), n=g.getAttribute('position').count, col=new Float32Array(n*3);
    for(let i=0;i<n;i++){
      const U=uv.getX(i), V=uv.getY(i), a=V*TWO_PI, hue=((V%1)+1)%1, rn=(1+Math.cos(a))*0.5, fn=(1+Math.sin(a))*0.5;
      let s=0.25+0.75*rn, val=0.35+0.65*fn, m=symmetricMod(U,V,axis,cnt,str);
      s*=0.6+0.4*m; val*=0.6+0.4*m;
      const c=hsvToRgb(hue,s,val);
      col[i*3]=c.r; col[i*3+1]=c.g; col[i*3+2]=c.b;
    }
    g.setAttribute('color', new THREE.BufferAttribute(col,3));
    planeOverlay=new THREE.Mesh(g,new THREE.MeshBasicMaterial({vertexColors:true,side:THREE.DoubleSide,transparent:true,opacity:0.98}));
    planeOverlay.frustumCulled=false; planeGroup.add(planeOverlay);
  }

  /* -----------------------------------------------------------------------
     Rectangle perimeter - use TorusMapper.rectPerimeterData to generate
     - rectPerimeterData returns planeLoops and torusLoops that are already
       split when wrapping occurs so we avoid connected seams across edges
     - render each loop as its own Line. Add final point to close visuals
     ----------------------------------------------------------------------- */
  if(drawMappedRect.checked){
    const rp = tmapper.rectPerimeterData(+rectU.value, +rectV.value, +rectUsz.value, +rectVsz.value, 256);

    // Build plane loops and torus loops from returned arrays
    planeRectLines = rp.planeLoops.map(loop => {
      // ensure closed visual loop by adding first point at end if not equal
      if(loop.length>1 && (loop[0][0] !== loop[loop.length-1][0] || loop[0][2] !== loop[loop.length-1][2])) loop.push(loop[0]);
      return toLine(loop, mapRectMat);
    });
    mappedTorLines = rp.torusLoops.map(loop => {
      if(loop.length>1 && (loop[0][0] !== loop[loop.length-1][0] || loop[0][1] !== loop[loop.length-1][1] || loop[0][2] !== loop[loop.length-1][2])) loop.push(loop[0]);
      return toLine(loop, mappedTorMat);
    });

    // Add to scene
    planeRectLines.forEach(L=>planeGroup.add(L));
    mappedTorLines.forEach(L=>torusGroup.add(L));

    // Log compact summary and full object for debugging
    console.groupCollapsed('TorusMapper.rectPerimeterData');
    console.log('params', tmapper.getParams());
    console.log('requested rect Uc,Vc,Usz,Vsz', +rectU.value, +rectV.value, +rectUsz.value, +rectVsz.value);
    console.log('uv points total:', rp.uv.length, 'planeLoops:', rp.planeLoops.length, 'torusLoops:', rp.torusLoops.length);
    console.log('planeLoops[0] sample:', rp.planeLoops[0] && rp.planeLoops[0].slice(0,6));
    console.log('torusLoops[0] sample:', rp.torusLoops[0] && rp.torusLoops[0].slice(0,6));
    console.log('full object rp:', rp);
    console.groupEnd();
  }

  /* -----------------------------------------------------------------------
     Spiral arc - use TorusMapper.spiralArcData
     - draw plane and torus arcs
     ----------------------------------------------------------------------- */
  if(showSpiralArc.checked){
    const mode = arcCloseSingle.checked ? 'close1' : 'blue';
    const ad = tmapper.spiralArcData(+thetaEl.value*TWO_PI, 0.0, { mode, samples:400 });

    arcLine      = toLine(ad.torusPts, arcMat);      torusGroup.add(arcLine);
    planeArcLine = toLine(ad.planePts,  planeArcMat); planeGroup.add(planeArcLine);

    console.groupCollapsed('TorusMapper.spiralArcData');
    console.log('params', tmapper.getParams());
    console.log('mode', ad.mode, 'samples', ad.torusPts.length);
    console.log('torusPts sample:', ad.torusPts.slice(0,6));
    console.log('planePts sample:', ad.planePts.slice(0,6));
    console.log('full object ad:', ad);
    console.groupEnd();
  }

  /* -----------------------------------------------------------------------
     Cross-section square - use TorusMapper.crossSquareData
     - crossSquareData returns exactly 4 corners; add first back to close when rendering
     ----------------------------------------------------------------------- */
  if(showCrossSquare.checked){
    const sd = tmapper.crossSquareData(+thetaEl.value*TWO_PI, +sizeEl.value);
    const corners = sd.torusPts.slice(); // 4 corners
    if(corners.length===4) corners.push(corners[0]); // make closed loop for visual
    squareLine     = toLine(corners, squareMat);     torusGroup.add(squareLine);
    planeSquareLine= toLine(sd.planePts, planeArcMat);   planeGroup.add(planeSquareLine);

    console.groupCollapsed('TorusMapper.crossSquareData');
    console.log('params', tmapper.getParams());
    console.log('center', sd.center);
    console.log('axes', sd.axes);
    console.log('torus corner points (4):', sd.torusPts);
    console.log('full object sd:', sd);
    console.groupEnd();
  }
}

/* =========================================================================
   Picking code - click plane or torus to place markers and show UV mapping
   - picks from currentPick mesh (which contains uv attribute)
   - when clicking plane we map plane uv to torus via TorusMapper
   ========================================================================= */

const raycaster=new THREE.Raycaster(), mouse=new THREE.Vector2();

function onPointer(ev){
  scene.updateMatrixWorld(); camera.updateMatrixWorld();
  const r=renderer.domElement.getBoundingClientRect();
  mouse.set(((ev.clientX-r.left)/r.width)*2-1, -((ev.clientY-r.top)/r.height)*2+1);
  raycaster.setFromCamera(mouse,camera);

  let hits=[], target=null;
  if(currentPick){ hits=raycaster.intersectObject(currentPick,false); if(hits.length) target='torus'; }
  if(!hits.length && planeObj){ hits=raycaster.intersectObject(planeObj.mesh,false); if(hits.length) target='plane'; }
  if(!hits.length) return;

  hits.sort((a,b)=>a.distance-b.distance);
  const h=hits[0];

  if(target==='torus'){
    // When clicking the torus mesh, the raycast result contains uv coordinates
    // Put the marker at the picked 3D point and show corresponding uv location on plane
    torusMarker.position.copy(torusGroup.worldToLocal(h.point.clone())); torusMarker.visible=true;
    const uv=h.uv||new THREE.Vector2(0,0);
    planeMarker.position.set((uv.x-0.5)*TWO_PI,0,(uv.y-0.5)*TWO_PI); planeMarker.visible=true;
  }else{
    // If we clicked the plane, get uv and map to torus via TorusMapper for selected params
    const uv=h.uv||new THREE.Vector2(0,0);
    const mapper = new TorusMapper({ mode:(modeSel.value==='std'?'std':'clifford'), R:+Rslider.value, r:+rslider.value, shear:(spiral.checked?+twistEl.value:0) });
    const P=mapper.posFromUV(uv.x,uv.y);
    torusMarker.position.copy(P); torusMarker.visible=true;
    planeMarker.position.copy(planeGroup.worldToLocal(h.point.clone())); planeMarker.visible=true;
  }
}
renderer.domElement.addEventListener('pointerdown', onPointer);

/* Expose TorusMapper if external code wants to reuse it - optional convenience */
window.TorusMapper = TorusMapper;

/* =========================================================================
   UI sync and event wiring
   - all input changes call rebuild so logs and visuals update immediately
   ========================================================================= */

function syncLabels(){
  Rval.textContent=(+Rslider.value).toFixed(2); rval.textContent=(+rslider.value).toFixed(2);
  suval.textContent=String(+suslider.value); svval.textContent=String(+svslider.value);
  twistV.textContent=(+twistEl.value).toFixed(2);
  symCountV.textContent=symCount.value; symStrengthV.textContent=(+symStrength.value).toFixed(2);
  rectUv.textContent=(+rectU.value).toFixed(2); rectVv.textContent=(+rectV.value).toFixed(2);
  rectUszv.textContent=(+rectUsz.value).toFixed(2); rectVszv.textContent=(+rectVsz.value).toFixed(2);
  thetav.textContent=(+thetaEl.value).toFixed(3); sizev.textContent=(+sizeEl.value).toFixed(2);
}

/**
 * Link behavior: when spiral is enabled, prefer showing spiral arc
 * otherwise show cross square
 */
function linkArcSquareToSpiral(){
  if(spiral.checked){ showSpiralArc.checked=true; showCrossSquare.checked=false; }
  else { showSpiralArc.checked=false; showCrossSquare.checked=true; }
}

// Wire up events. We intentionally rebuild on every relevant input
[
  [modeSel,'change'],[eqArc,'change'],[spiral,'change'],
  [twistEl,'input'],[twistEl,'change'],
  [Rslider,'input'],[rslider,'input'],[suslider,'input'],[svslider,'input'],
  [showOverlay,'change'],[showPlaneOverlay,'change'],
  [symAxis,'change'],[symCount,'input'],[symCount,'change'],
  [symStrength,'input'],[symStrength,'change'],
  [rectU,'input'],[rectV,'input'],[rectUsz,'input'],[rectVsz,'input'],[drawMappedRect,'change'],
  [thetaEl,'input'],[thetaEl,'change'],[sizeEl,'input'],[sizeEl,'change'],
  [showSpiralArc,'change'],[arcCloseSingle,'change'],[showCrossSquare,'change']
].forEach(([el,ev])=>{
  el.addEventListener(ev,()=>{
    if(el===spiral && ev==='change') linkArcSquareToSpiral();
    syncLabels();
    // Rebuild everything and emit new mapper logs
    rebuild();
  });
});

/* =========================================================================
   Resize and render loop
   - on resize we rebuild to keep geometry sizes consistent
   ========================================================================= */

function resize(){ const w=innerWidth,h=innerHeight; renderer.setSize(w,h,false); camera.aspect=w/h; camera.updateProjectionMatrix(); rebuild(); }
addEventListener('resize', resize);

(function init(){ syncLabels(); linkArcSquareToSpiral(); rebuild(); resize(); })();
(function loop(){ requestAnimationFrame(loop); controls.update(); renderer.render(scene,camera); })();

</script>
</body>
</html>
